def DavisDietzenNOISEf50tt(mymoves, othermoves, currentRound):
    if currentRound < 2:
      return False
    num_of_betray = 0
    for i in othermoves:
      if i:
        num_of_betray += 1
    if currentRound / 2 <= num_of_betray:
      if othermoves[-2] and othermoves[-1]:
       return True
      else:
        return True
    if currentRound / 2 >= num_of_betray:
      if othermoves[-2] and othermoves[-1]:
       return True
      else:
       return False

def DavisDietzenNOISEfoste(mymoves, othermoves, currentRound):
  if currentRound < 2:
    return False
  import random
  random.sample(population=[0, 1], k=1, counts=[4, 1])
  random.choices(population=[0, 1], weights=[0.9, 0.1])
  0 if random.random() < 0.9 else 1
  if random.random == 1:
    return False
  else:
     if othermoves[-2] and othermoves[-1]:
      return True
     else:
      return False

def DavisDietzenNOISEufoste(mymoves, othermoves, currentRound):
  if currentRound < 2:
    return False
  import random
  random.sample(population=[0, 1], k=1, counts=[4, 1])
  random.choices(population=[0, 1], weights=[0.9, 0.1])
  0 if random.random() < 0.9 else 1
  if random.random == 1:
    return False
  else:
     if othermoves[-2] and othermoves[-1]:
      return True
     else:
      return False

def DavisDietzenNOISEf75tt3p(mymoves, othermoves, currentRound):
    if currentRound < 3:
      if currentRound < 2:
       return False
      else:
       if othermoves[-2] and othermoves[-1]:
        return True
       else:
        return False
    num_of_betray = 0
    for i in othermoves:
      if i:
        num_of_betray += 1
    if currentRound / 2.25 <= num_of_betray:
      if othermoves[-3] and othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-3] and othermoves[-1]:
       return True
      else:
        return False
    if currentRound / 2.25 >= num_of_betray:
      if othermoves[-3] and othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-3] and othermoves[-1]:
       return False
      else:
       return False
    else:
      return False

def DavisDietzenNOISEf50tt3p(mymoves, othermoves, currentRound):
    if currentRound < 3:
      if currentRound < 2:
       return False
      else:
       if othermoves[-2] and othermoves[-1]:
        return True
       else:
        return False
    num_of_betray = 0
    for i in othermoves:
      if i:
        num_of_betray += 1
    if currentRound / 2 <= num_of_betray:
      if othermoves[-3] and othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-3] and othermoves[-1]:
       return True
      else:
        return False
    if currentRound / 2 >= num_of_betray:
      if othermoves[-3] and othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-2] and othermoves[-1]:
       return True
      if othermoves[-3] and othermoves[-1]:
       return False
      else:
       return False
    else:
      return False

def DavisDietzenNOISEidkbombttoste(mymoves, othermoves, currentRound):
  num_of_betray = 0
  for i in othermoves:
    if i:
      num_of_betray += 1
  if currentRound < 10:
    return False
  if num_of_betray <= currentRound * 0.1:
    return False
  else:
    random.sample(population=[0, 1], k=1, counts=[4, 1])
    random.choices(population=[0, 1], weights=[0.9, 0.1])
  0 if random.random() < 0.9 else 1
  if random.random == 1:
    return False
  else:
     if othermoves[-2] and othermoves[-1]:
      return True
     else:
      return False