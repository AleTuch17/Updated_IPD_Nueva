def HarrisonQianAdaptive(mymoves, othermoves, currentRound):
  # first index is us, second index is them
  start = [False] * 6 + [True] * 5
  if currentRound < len(start):
    return start[currentRound]
  payoff = [[5, 0], [9, 1]]
  c_score = sum(payoff[mymoves[i]][othermoves[i]] for i, value in enumerate(mymoves) if value == False)
  d_score = sum(payoff[mymoves[i]][othermoves[i]] for i, value in enumerate(mymoves) if value == True)

  if c_score > d_score:
    return False
  return True

def HarrisonQianAdaptiveFeeder1(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder2(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder3(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder4(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder5(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder6(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder7(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder8(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True

def HarrisonQianAdaptiveFeeder9(mymoves, othermoves, currentRound):
  import math
  def flips_away(arr1, arr2): # assuming same length
    flips = sum(bit1 != bit2 for bit1, bit2 in zip(arr1, arr2))
    return flips
  length = 11
  master_key = [False] * 6 + [True] * 5
  if currentRound < length:
    if flips_away(othermoves[:currentRound], master_key[:currentRound]) <= math.floor(currentRound/length * 2):
      return False
    return True
  if flips_away(othermoves[:length], master_key) <= 2:
    return False
  return True